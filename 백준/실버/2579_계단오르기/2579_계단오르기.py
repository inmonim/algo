import os, sys

sys.stdin = open(os.path.dirname(os.path.realpath(__file__)) + '/input.txt')

# 0부터 N까지의 계단을 오르는데, 다음 칸 또는 다다음 칸으로 이동할 수 있다.

# 다만, 연속된 계단을 세 번 이상 밟으면 안 되며, 세 칸 이상 한번에 올라갈 수 없다.

# 계단마다 점수가 있으며, 이 점수를 최대화 할 수 있는 방법을 찾는다.

# ==========

# n번째 계단을 밟았을 때, 해당 칸에 연속 두 번으로 올라온 것이라면 무조건 다음 번엔 한 칸을 건너 뛰어야 한다...

# n번째 계단에 도달했을 때 최대의 값을 기록하는 것은 위의 문제로 힘들지 않을까?

# 경우의 수마다 각자의 값을 가지고 가는 것도 쉽지 않을 것 같다...

# 가지치기가 힘들 수 있으므로, 일단 브루트포스로 시작해보자.


# import sys

input = sys.stdin.readline

# N = int(input())

# stairs = [int(input()) for _ in range(N)]

# answer_list = []

# score, now_step, flag = 0,-1,0
# Q = [(score, now_step, flag)]

# while Q:

#     score, now_step, flag = Q.pop(0)
#     if now_step == N-1:
#         answer_list.append(score)

#     for ns in [1, 2]:
#         if flag == ns+1:
#             continue
#         next_step = now_step + ns
#         if next_step >= N:
#             break
        
#         new_score = score + stairs[next_step]
#         next_flag = 1 if ns == 2 else flag + 1

#         Q.append((new_score, next_step, next_flag))

# print(max(answer_list))

# 당연히 모든 경우의 수 (심지어 이전에 더 높은 점수로 지나온 곳을 낮은 점수로 지나가는 것까지 포함해서)를 종합하며,
# 심지어 한 경우의 연산에 여러 개의 탈출 조건과 플래그 연산이 필요하므로 무조건 시간 초과가 발생한다.

# 생각해보니 이건 나를 과거에 심하게 괴롭혔던 문제다.

# 아무리 가지를 잘 쳐낸 BFS라고 해도 시간 초과가 날 수밖에 없는 문제고, DP를 이용한 풀이가 필요했다.

# 백준의 예시 문제에서 계단을 arr로 지정하고 따라 올라가며 직접 계산하며, 가장 높은 경우의 값을 max라는 list에 저장한다고 생각해보자. 연속해서 밟았는지는 flag로 표현하겠다.

# 1은 밟거나 안 밟거나다. max = [10]

# 2는 1을 밟고 올라오느냐, 한번에 올라 왔느냐다. 당연히 1+2가 높다. max = [10, 30]

# 3은 1을 밟고 두 칸을 뛰었는지, 2를 밟고 한 칸 올라왔는지다. 2+3이 높으므로, max = [10, 30, 35]

# 4는 어떨까?

# 1과 2를 밟고 두 칸을 뛰었거나, 1과 3을 밟고 한 칸 올라왔는지다.

# 여기서부터는 이전 경우의 수 마다의 값을 생각해야한다.

# 전자인 1과 2를 밟고 두 칸을 뛴 경우를 표현해보자.

# 1과 2를 밟았다는 것은, arr의 1번째와 2번째를 더한 값인 max의 두 번째 값, 30을 가져온다는 이야기이다.

# 그리고 arr의 네 번째 값인 25를 거기에 더한다는 것이다.

# 이를 식으로 표현하면 arr[1] + arr[2] + arr[4]이며, 이는 max[2] + arr[4] 이다. (편의상 인덱스를 1부터 잡았다.)

# 후자를 생각해보자.

# 1과 3을 밟고 한 칸 올라왔다는 것은, 1은 연속해서 밟았는지를 생각할 필요가 없다는 것이다. 즉, 가능한 최대 값인 max를 주면 된다.

# max[1]은 이전 경우의 수들의 총합을 가지므로, 3은 arr에서 가져와 더하면 된다. (만약 3을 max에서 가져오면 이전 경우의 값들의 총합이 중복으로 더해지는 셈이 된다.)

# 식으로는 max[1] + arr[3] + arr[4]이다.

# 이 두 개의 경우의 수에서 만들어진 값 중 높은 값을 max[4]에 지정하면 된다.

# 즉, max(max[1] + arr[3] + arr[4], max[2] + arr[4]) == max(50, 55)

# 4번의 경우, 55가 더 높으므로, max[4]는 55가 되었다.

# 확실히 이해하기 위해 5번까지 계산을 해보자.

# 현재까지 max 리스트는 다음과 같다.

# [10, 30, 35, 55]

# 5번 계단까지 오는 경우의 수는 다음과 같다.

# 1 - 3 - 5

# 1 - 2 - 4 - 5

# 2 - 3 - 5

# 2 - 4 - 5

# 이를 이전에 만든 식으로 풀어보면 다음과 같아진다.

# arr[1] + arr[3] + arr[5] == 10 + 15 + 10 == 35

# max[2] + arr[4] + arr[5] == 30 + 25 + 10 == 65

# max[3] + arr[5] == 35 + 10 == 45

# arr[2] + arr[4] + arr[5] == 20 + 25 + 10 == 55

# 한 칸 올라오며, 인덱스가 1 높아졌을 뿐, 보다시피 두 번째와 세 번째 경우는 이전에 세운 식들이다.

# 둘 중 하나는 경우의 수 중 최댓값을 가졌다.

# 점화식에서는 65를 반환하고, max[5]에 넣을 것이다.

# 더욱 확실히 하기 위해 6번 계단도 보자.

# 1 - 2 - 4 - 6

# 1 - 3 - 4 - 6

# 1 - 3 - 5 - 6

# 2 - 3 - 5 - 6

# 2 - 4 - 6

# 다시 식을 만들어보자.

# arr[2] + arr[3] == max[3]

# arr[1] + arr[3] + arr[4] == max[4] 였음을 기억하자!

# ---

# max[2] + arr[4] + arr[6] == max[4] + arr[6] == 75

# arr[1] + arr[3] + arr[4] + arr[6] == max[4] + arr[6] == 75

# arr[1] + arr[3] + arr[5] + arr[6] == 55

# max[3] + arr[5] + arr[6] == 65

# arr[2] + arr[4] + arr[6] == 65

# 이번에도 똑같이 max[3] + arr[5] + arr[6], max[4] + arr[6] 중 하나의 값이 여전히 최댓값을 가지고 있는 것을 볼 수 있다.

# max[3] 이후에는 arr[5]가 오고, max[4] 이후에는 arr[6]이 오듯 두 칸을 건너 뛰기 때문에
# 
# '이전에 연속해서 올라왔는가?'를 전혀 고려할 필요가 없으며, 이전 단계를 모두 더한 가능한 최대 값을 갖고 있다.

# 따라서 지금과 직전을 더할지, 지금만 더할지를 고려하면 되는 것이다.

# max값을 추가할 때 다음 단계에서 '이전과 이전의 직전을 더한 값을 쓰면 어떡하지?'라는 생각도 할 필요 없다.

# max의 값이 쓰이는 경우는 위에서 말했듯이 '이전에 연속해서 올라왔는가?'를 고려할 필요가 없는, 최소 +3 이상의 단계에서 쓰이게 되니 말이다.

# 이제 식을 세우면 다음과 같다.

import sys

p=sys.stdin.readline

N=int(p())

a=[int(p()) for _ in range(N)]

if N<=2:
    print(sum(a))

else:
    s=[a[0], a[0]+a[1], max(a[0]+a[2], a[1]+a[2])]

    for i in range(3, N):
        s.append(max(s[i-3] + a[i-1] + a[i], s[i-2] + a[i]))
    print(s[-1])